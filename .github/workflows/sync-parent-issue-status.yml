name: Sync Parent Issue Status

on:
  push:
    branches:
      - main

permissions:
  issues: write
  contents: read
  repository-projects: write

env:
  PROJECT_NUMBER: ${{ secrets.PROJECT_NUMBER }}
  PROJECT_OWNER: ${{ vars.PROJECT_OWNER || github.repository_owner }}
  PROJECT_STATUS_FIELD_NAME: ${{ vars.PROJECT_STATUS_FIELD_NAME }}
  STATUS_OPTION_TODO: ${{ vars.STATUS_OPTION_TODO }}
  STATUS_OPTION_IN_PROGRESS: ${{ vars.STATUS_OPTION_IN_PROGRESS }}
  STATUS_OPTION_DONE: ${{ vars.STATUS_OPTION_DONE }}

jobs:
  sync_parent_status_from_subissues:
    runs-on: ubuntu-latest
    steps:
      - name: Create GitHub App token
        uses: actions/create-github-app-token@v1
        id: app-token
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
          owner: ${{ env.PROJECT_OWNER || github.repository_owner }}
      - name: Sync parent issue Project status from sub-issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const { owner, repo } = context.repo;
            const projectNumber = process.env.PROJECT_NUMBER;
            if (!projectNumber) {
              core.setFailed('PROJECT_NUMBER secret is not set. Define it in repository secrets.');
              return;
            }
            const statusFieldName = process.env.PROJECT_STATUS_FIELD_NAME || 'Status';
            const optionTodo = process.env.STATUS_OPTION_TODO || 'Todo';
            const optionInProgress = process.env.STATUS_OPTION_IN_PROGRESS || 'In Progress';
            const optionDone = process.env.STATUS_OPTION_DONE || 'Done';
            const ownerLogin = process.env.PROJECT_OWNER || owner;
            const graph = github.graphql;

            const commits = context.payload.commits || [];
            const issueNumbers = new Set();
            const issueRegex = /(close|closes|closed|fix|fixes|fixed|resolve|resolves|resolved)\s+#(\d+)/ig;

            for (const commit of commits) {
              const matches = commit.message.matchAll(issueRegex);
              for (const match of matches) {
                issueNumbers.add(parseInt(match[2], 10));
              }
            }

            if (issueNumbers.size === 0) {
              core.info('No linked issue numbers found in commit messages. Skipping.');
              return;
            }

            async function getProject() {
              const number = Number(projectNumber);
              let data = await graph(
                `query($login:String!, $number:Int!){ organization(login:$login){ projectV2(number:$number){ id title fields(first:100){ nodes { __typename ... on ProjectV2FieldCommon { id name } ... on ProjectV2SingleSelectField { id name options { id name } } } } } } }`,
                { login: ownerLogin, number }
              ).catch(() => null);
              let project = data?.organization?.projectV2 || null;
              if (!project) {
                data = await graph(
                  `query($login:String!, $number:Int!){ user(login:$login){ projectV2(number:$number){ id title fields(first:100){ nodes { __typename ... on ProjectV2FieldCommon { id name } ... on ProjectV2SingleSelectField { id name options { id name } } } } } } }`,
                  { login: ownerLogin, number }
                ).catch(() => null);
                project = data?.user?.projectV2 || null;
              }
              if (!project) throw new Error(`ProjectV2 #${projectNumber} not found under ${ownerLogin}`);
              return project;
            }

            async function addToProject(projectId, contentId) {
              const add = await graph(
                `mutation($projectId:ID!,$contentId:ID!){ addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}){ item { id } } }`,
                { projectId, contentId }
              );
              return add?.addProjectV2ItemById?.item?.id;
            }

            async function findExistingItemId(projectId, contentId) {
              const data = await graph(
                `query($projectId:ID!){ node(id:$projectId){ ... on ProjectV2 { id items(first:100){ nodes { id content { __typename ... on Issue { id } ... on PullRequest { id } } } } } } }`,
                { projectId }
              );
              const items = data?.node?.items?.nodes || [];
              const found = items.find(n => n?.content?.id === contentId);
              return found?.id || null;
            }

            async function findOrCreateItemId(project, contentId) {
              try {
                const itemId = await addToProject(project.id, contentId);
                if (itemId) return itemId;
              } catch (e) {
                const existingId = await findExistingItemId(project.id, contentId);
                if (existingId) return existingId;
                throw e;
              }
              const existingId = await findExistingItemId(project.id, contentId);
              return existingId;
            }

            async function getIssueNode(ownerLogin, repo, number) {
              const data = await graph(
                `query($owner:String!,$repo:String!,$number:Int!){ repository(owner:$owner, name:$repo){ issue(number:$number){ id number state } } }`,
                { owner: ownerLogin, repo, number }
              );
              return data?.repository?.issue || null;
            }

            async function getParentsOfIssue(ownerLogin, repo, number) {
              const data = await graph(
                `query($owner:String!,$repo:String!,$number:Int!){ repository(owner:$owner, name:$repo){ issue(number:$number){ id number trackedInIssues(first:10){ nodes { id number repository{ name owner{ login } } } } } } }`,
                { owner: ownerLogin, repo, number }
              ).catch(() => null);
              const nodes = data?.repository?.issue?.trackedInIssues?.nodes || [];
              return nodes.map(n => ({ id: n.id, number: n.number, repo: n.repository.name, owner: n.repository.owner.login }));
            }

            async function getChildrenOfIssue(ownerLogin, repo, number) {
              const data = await graph(
                `query($owner:String!,$repo:String!,$number:Int!){ repository(owner:$owner, name:$repo){ issue(number:$number){ id number trackedIssues(first:100){ nodes { id number state repository{ name owner{ login } } } } } } }`,
                { owner: ownerLogin, repo, number }
              ).catch(() => null);
              const nodes = data?.repository?.issue?.trackedIssues?.nodes || [];
              return nodes.map(n => ({ id: n.id, number: n.number, state: n.state, repo: n.repository.name, owner: n.repository.owner.login }));
            }

            async function getItemStatusName(project, itemId, statusFieldName) {
              const data = await graph(
                `query($itemId:ID!){ node(id:$itemId){ ... on ProjectV2Item { id fieldValues(first:20){ nodes { __typename ... on ProjectV2ItemFieldSingleSelectValue { field { ... on ProjectV2FieldCommon { id name } ... on ProjectV2SingleSelectField { id name options { id name } } } optionId } } } } } }`,
                { itemId }
              );
              const fields = project.fields.nodes || [];
              const statusField = fields.find(f => f.name === statusFieldName);
              const values = data?.node?.fieldValues?.nodes || [];
              const sel = values.find(v => v?.field?.name === statusFieldName);
              if (!sel) return null;
              const option = (statusField.options || []).find(o => o.id === sel.optionId);
              return option?.name || null;
            }

            async function updateStatus(project, itemId, statusFieldName, optionName) {
              const fields = project.fields.nodes || [];
              const statusField = fields.find(f => f.name === statusFieldName);
              if (!statusField) throw new Error(`Status field '${statusFieldName}' not found in Project`);
              const option = (statusField.options || []).find(o => o.name === optionName);
              if (!option) throw new Error(`Option '${optionName}' not found in field '${statusFieldName}'`);
              await graph(
                `mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $optionId:String!){ updateProjectV2ItemFieldValue(input:{ projectId:$projectId, itemId:$itemId, fieldId:$fieldId, value:{ singleSelectOptionId:$optionId }}) { projectV2Item { id } } }`,
                { projectId: project.id, itemId, fieldId: statusField.id, optionId: option.id }
              );
            }

            const project = await getProject();

            for (const issueNumber of issueNumbers) {
              core.info(`Processing issue #${issueNumber}`);
              let parents = await getParentsOfIssue(ownerLogin, repo, issueNumber);
              if (!parents || parents.length === 0) {
                const self = await getIssueNode(ownerLogin, repo, issueNumber);
                if (self) parents = [{ id: self.id, number: self.number, repo, owner: ownerLogin }];
              }
              
              if (!parents || parents.length === 0) {
                core.info(`Could not find issue #${issueNumber} or its parents. Skipping.`);
                continue;
              }

              for (const parent of parents) {
                const children = await getChildrenOfIssue(parent.owner, parent.repo, parent.number);
                if (!children || children.length === 0) {
                  core.info(`Parent #${parent.number} has no sub-issues. Skipping changes.`);
                  continue; // no effect when no children
                }

                const childStatuses = [];
                for (const child of children) {
                  let status = optionTodo;
                  if (child.state === 'CLOSED') {
                    status = optionDone;
                  } else {
                    const childItemId = await findExistingItemId(project.id, child.id);
                    if (childItemId) {
                      const statusName = await getItemStatusName(project, childItemId, statusFieldName);
                      status = statusName || optionTodo;
                    }
                  }
                  childStatuses.push(status);
                }

                let target = null;
                if (childStatuses.every(s => s === optionDone)) {
                  target = optionDone;
                } else if (childStatuses.every(s => s === optionTodo)) {
                  target = optionTodo;
                } else {
                  target = optionInProgress;
                }

                if (!target) {
                  core.info(`No matching target for parent #${parent.number}. Skipping.`);
                  continue;
                }

                const parentIssue = await getIssueNode(parent.owner, parent.repo, parent.number);
                const parentItemId = await findOrCreateItemId(project, parentIssue.id);
                if (!parentItemId) {
                  core.info(`Could not resolve project item for parent #${parent.number}.`);
                  continue;
                }
                
                const currentParentStatus = await getItemStatusName(project, parentItemId, statusFieldName);
                if (currentParentStatus !== target) {
                  await updateStatus(project, parentItemId, statusFieldName, target);
                  core.info(`Updated parent #${parent.number} status: ${currentParentStatus} → ${target}`);
                } else {
                  core.info(`Parent #${parent.number} status already is ${target}, skipping update`);
                }
              }
            }
